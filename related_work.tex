\label{section:related_work}

The prior work that has informed the development of Twoville can be clustered into three main categories: computational making, programming languages for fabrication, and direct manipulation in user interfaces.

\subsection{Computational Making}
Rode et al.~\cite{rode15ctcm} define \textit{computational making} as the integration of computational thinking and several making-related activities and skills, namely ``aesthetics, creativity, construction, visualizing multiple representations, and understanding materials.'' Learners who engage in computational making integrate different kinds of thinking, including virtual and physical, algorithmic and aesthetic, and abstract and concrete.

Jacobs and Buechley~\cite{jacobs13codeable} discuss several advantages that computational design systems provide, including precision and automation, generativity and randomness, and parameterization.

Chytas et al.~\cite{chytas2018learning} held a series of workshops on parametric design and analyzed the participants' OpenSCAD~\cite{openscad} and BlocksCAD~\cite{blockscad} programs to understand the how parametric design contributes to the learning of programming. Half of the projects did not include any loops, and very few used conditional statements. These low frequencies can be explained to some degree by a bias toward novice programmers in an experimental environment. In our experience with Twoville, we have also found that many interesting objects can be made without flow control. Not every programming language feature is important in the initial stages of computational making, which we view positively.

A considerable number of projects have engaged learners in computational making via programmable textiles~\cite{rode15ctcm,buechley10lilypad,kafai14crafts}. In many of these projects, the constructed object is made of two distinct elements: a programmable embedded system and a physical housing, like a garment of clothing or a puppet. With Twoville, the physical artifact is itself the product of the computation. Once fabricated, the object is no longer tied to a computer.

\subsection{Programmatic Fabrication}
A growing but small number of programming environments have been developed for creating physical artifacts. Many are research projects, and only a few have had public releases.

Some tools confine the design space to two dimensions. The FlatCAD system of Johnson~\cite{johnson08flat}, for example, is used to programmatically trace out flat shapes that can be laser-cut and assembled into more complex objects. Turbak et al.~\cite{turbak12tangible} describe two blocks languages for generating design files that can be cut or engraved with laser cutters. Other tools support fabrication in three dimensions. Beetleblocks~\cite{koschitz12exploring} and Madeup~\cite{johnson17toward} both generate printable 3D models using imperative languages inspired by Logo. OpenSCAD and BlocksCAD provide declarative languages in which complex models are composed using simpler primitives.

Johnson~\cite{johnson08flat} observes that programming is not always the most natural means of interacting with a design. A more versatile design tool would additionally allow sketching and direct manipulation. Twoville is a two-dimensional design tool that supports both direct manipulation on the canvas and indirect manipulation through code.

\subsection{Direct Manipulation}
Schneiderman~\cite{shneiderman19931} explored direct manipulation across a diverse set of professional domains and summarized it as an interactive mode of editing where actions are rapidly executed, immediately observable, and easily reversed. Physically interacting with the system produces direct, visual results. These principles of interactive design have since been applied to integrated development environments (IDEs) to make the generation and editing of code more intuitive.

Adam et al.~\cite{adam19dm} compared direct manipulation interfaces to text interfaces in a study of novice programmers. Half of the subjects used a tool that generated code as they directly interacted with the data. The other half used a text editor. The direction manipulation group solved fewer programming exercises than the text group but achieved higher scores on the exercises they did complete. In exercises involving conditionals and repetition, each editing mode had its advantages. Adam et al. hypothesize that an ideal interface would combine both methods of input.

Hundhausen et al.~\cite{hundhausen09dm} investigated whether direct manipulation makes programming more accessible than text and whether the knowledge acquired using a direct manipulation interface to program transfers to a text interface. They found that students in an introductory programming course who used direct manipulation completed coding tasks more accurately and quickly than students using text. Further, when this experimental group switched to text for the final exercise, they continued to outperform the control group. \textit{Dual-coding theory}~\cite{clark1991dual}, which states that knowledge is strengthened when it is encoded in multiple ways, may explain this positive result.

The CapStudio project of Fukahori et al.~\cite{fukahori14capstudio} is a game editor that allows game developers to write source code and directly manipulate the game objects in the visual display. They label a source code change that propagates to the visual display a {\em forward edit}, and a change in the visual display that propagates to the source code a {\em backward edit}. We apply the term {\em bidirectional editor} to Twoville.

The Sketch-and-Sketch project of Chugh et al.~\cite{chugh16dm} heavily inspires our work on Twoville. Both projects are environments for indirectly coding and directly manipulating vector graphics designs. When a Sketch-and-Sketch program is evaluated, each visual property of a shape---like size and position---is stored with a \textit{trace}, which is an unevaluated representation of the expression that generated it. This expression is composed of one or more parameters. When the designer manipulates the shape using the mouse, the new value of the property and the source expression are used to solve for one of the parameters. The new value replaces the old value in the source code. Twoville differs in several ways from Sketch-and-Sketch. It is an imperative language rather than a functional language, and it relies on simpler heuristics to update ambiguous or complex expressions. These adaptations were intentionally chosen to cater to an audience of computational makers and young learners.
